import jwt from 'jsonwebtoken';
// import { getAppDb } from '../db/setup.js'; // Not strictly needed if not re-fetching user from DB here

const JWT_SECRET = process.env.JWT_SECRET || 'yourFallbackSecretKeyForDevelopmentOnly'; // Ensure this is in .env for production

export const protect = async (req, res, next) => {
  let token;
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      token = req.headers.authorization.split(' ')[1];
      const decoded = jwt.verify(token, JWT_SECRET);
      
      // Ensure JWT payload has id, email, and role as generated by authController
      if (!decoded || typeof decoded.id === 'undefined' || typeof decoded.email === 'undefined' || typeof decoded.role === 'undefined') {
        console.error('Token decoded but missing required fields (id, email, role):', decoded);
        return res.status(401).json({ message: 'Not authorized, token payload invalid' });
      }

      // Attach user information (including role) from token to request object
      req.user = { 
        id: decoded.id, 
        email: decoded.email, 
        role: decoded.role 
      };

      // Optional: Fetch full user from DB to ensure they still exist/are active.
      // This adds a DB query per protected request but ensures user data is fresh and valid.
      // const db = await getAppDb();
      // const dbUser = await db.get('SELECT id, email, name, role FROM users WHERE id = ?', decoded.id);
      // if (!dbUser) {
      //   return res.status(401).json({ message: 'Not authorized, user not found in database' });
      // }
      // req.user = dbUser; // Overwrite with potentially more complete/fresh user data

      next();
    } catch (error) {
      console.error('Token verification failed:', error.name, error.message);
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({ message: 'Not authorized, token expired' });
      } 
      if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({ message: 'Not authorized, token malformed' });
      }
      return res.status(401).json({ message: 'Not authorized, token verification failed' });
    }
  } else {
    // No token found in headers
    return res.status(401).json({ message: 'Not authorized, no token provided' });
  }
};