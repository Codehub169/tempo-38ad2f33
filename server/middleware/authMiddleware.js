import jwt from 'jsonwebtoken';
import { getAppDb } from '../db/setup.js';

export const protect = async (req, res, next) => {
  let token;
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      token = req.headers.authorization.split(' ')[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'yourFallbackSecretKey'); // Use environment variable for secret
      
      // const db = await getAppDb(); // Uncomment if fetching user from DB
      // Optionally, fetch user from DB to ensure they still exist/are active
      // req.user = await db.get('SELECT id, email, name FROM users WHERE id = ?', decoded.id);
      
      // For simplicity now, just use decoded payload if it contains necessary user info
      // Ensure JWT payload has id and email, as generated by authController
      if (!decoded || typeof decoded.id === 'undefined' || typeof decoded.email === 'undefined') {
        // This case should ideally not happen if tokens are generated correctly
        console.error('Token decoded but missing id or email:', decoded);
        return res.status(401).json({ message: 'Not authorized, token payload invalid' });
      }
      req.user = { id: decoded.id, email: decoded.email }; 

      // The check below is more relevant if fetching user from DB and user might not be found.
      // With the current simplified approach, req.user will always be an object if decoded is valid.
      // if (!req.user) { 
      //   return res.status(401).json({ message: 'Not authorized, user not found' });
      // }
      next();
    } catch (error) {
      console.error('Token verification failed:', error.message);
      // Handle specific JWT errors like TokenExpiredError, JsonWebTokenError
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({ message: 'Not authorized, token expired' });
      } 
      return res.status(401).json({ message: 'Not authorized, token failed' });
    }
  }

  if (!token) {
    return res.status(401).json({ message: 'Not authorized, no token' });
  }
};
