import jwt from 'jsonwebtoken';
// import { getAppDb } from '../db/setup.js'; // Not strictly needed if not re-fetching user from DB here

const JWT_SECRET = process.env.JWT_SECRET || 'yourFallbackSecretKeyForDevelopmentOnly'; // Ensure this is in .env for production

export const protect = async (req, res, next) => {
  let token;
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      token = req.headers.authorization.split(' ')[1];
      const decoded = jwt.verify(token, JWT_SECRET);
      
      // Ensure JWT payload has id, email, and role as generated by authController
      if (!decoded || typeof decoded.id === 'undefined' || typeof decoded.email === 'undefined' || typeof decoded.role === 'undefined') {
        console.error('Token decoded but missing required fields (id, email, role):', decoded);
        return res.status(401).json({ message: 'Not authorized, token payload invalid' });
      }

      // Attach user information (including role) from token to request object
      req.user = { 
        id: decoded.id, 
        email: decoded.email, 
        role: decoded.role 
      };

      next();
    } catch (error) {
      console.error('Token verification failed:', error.name, error.message);
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({ message: 'Not authorized, token expired' });
      } 
      if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({ message: 'Not authorized, token malformed' });
      }
      return res.status(401).json({ message: 'Not authorized, token verification failed' });
    }
  } else {
    // No token found in headers
    return res.status(401).json({ message: 'Not authorized, no token provided' });
  }
};

export const authorize = (roles = []) => {
  if (typeof roles === 'string') {
    roles = [roles];
  }
  return (req, res, next) => {
    if (!req.user) { // Should be set by 'protect' middleware
      return res.status(401).json({ message: 'Not authorized, user information missing in request' });
    }
    if (roles.length && !roles.includes(req.user.role)) {
      // User's role is not authorized
      return res.status(403).json({ message: 'Forbidden: You do not have the required role to perform this action' });
    }
    next(); // Role is authorized
  };
};